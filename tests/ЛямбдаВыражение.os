#Использовать ".."
#Использовать reflector

Перем Рефлектор; // Рефлектор

&Тест
Процедура УстанавливаетсяИнтерфейс() Экспорт

	// Дано
	
	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х");

	// Когда

	ЛямбдаВыражение.Интерфейс(
		ФункциональныеИнтерфейсы.УниФункция()
	);

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мИнтерфейс"))
		.Равно(ФункциональныеИнтерфейсы.УниФункция());

КонецПроцедуры

&Тест
Процедура УстанавливаетсяПроизвольныйИнтерфейс() Экспорт

	// Дано
	
	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х");

	Интерфейс = Новый ИнтерфейсОбъекта();
	Интерфейс.ФункцияИнтерфейса("Тест", 1);

	// Когда

	ЛямбдаВыражение.Интерфейс(
		Интерфейс
	);

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мИнтерфейс"))
		.Равно(Интерфейс);

КонецПроцедуры

&Тест
Процедура ПриУстановкеИнтерфейсаПроверяетсяЧтоМногострочнаяФункцияДолжнаСодержатьВозврат() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> 
	|	х = х + 1;
	|");

	Параметры = Новый Массив;
	Параметры.Добавить(ФункциональныеИнтерфейсы.УниФункция());

	// Тогда

	Ожидаем.Что(ЛямбдаВыражение)
		.Метод("Интерфейс", Параметры)
		.ВыбрасываетИсключение("Лямбда выражение должно возвращать значение");

КонецПроцедуры

&Тест
Процедура ПриУстановкеИнтерфейсаПодставляетсяВозвратВОднострочнуюФункцию() Экспорт

	// Дано
	
	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> ВозвратныйВозврат");

	// Когда

	ЛямбдаВыражение.Интерфейс(
		ФункциональныеИнтерфейсы.УниФункция()
	);

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "РазобранноеВыражение").Тело)
		.Равно("Возврат ВозвратныйВозврат");

КонецПроцедуры

&Тест
Процедура ПриУстановкеИнтерфейсаПроверяетсяЧтоПроцедураНеДолжнаСодержатьВозвратЗначения() Экспорт

	// Дано
	
	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х");

	Параметры = Новый Массив;
	Параметры.Добавить(ФункциональныеИнтерфейсы.УниПроцедура());

	// Тогда

	Ожидаем.Что(ЛямбдаВыражение)
		.Метод("Интерфейс", Параметры)
		.ВыбрасываетИсключение("Лямбда выражение не должно возвращать значение");

	// Тогда

КонецПроцедуры

&Тест
Процедура УстанавливаетсяКонтекст() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х");

	Контекст = Новый Структура("А", 1);

	// Когда

	ЛямбдаВыражение.Контекст(Контекст);

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мКонтекст"))
		.Равно(Контекст);

КонецПроцедуры

&Тест
Процедура ПроверкаТипаКонтекста() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х");

	Параметры = Новый Массив;
	Параметры.Добавить(Новый Массив);

	// Тогда

	Ожидаем.Что(ЛямбдаВыражение)
		.Метод("Контекст", Параметры)
		.ВыбрасываетИсключение("Контекстом для лямбда выражения может выступать только структура");

КонецПроцедуры

&Тест
Процедура ОбъектЗахватывается() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х");

	// Когда

	ЛямбдаВыражение.ЗахватитьОбъект(ЭтотОбъект);

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мОбъект"))
		.Равно(ЭтотОбъект);

КонецПроцедуры

&Тест
Процедура ОбъектСФункциейСоздаётся() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х")
		.Интерфейс(ФункциональныеИнтерфейсы.УниФункция());

	// Когда

	Объект = ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Объект.Применить(1)).Равно(1);

КонецПроцедуры

&Тест
Процедура ОбъектСПроцедуройСоздаётся() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> х = х + 1")
		.Интерфейс(ФункциональныеИнтерфейсы.УниПроцедура());

	// Когда

	Объект = ЛямбдаВыражение.ВОбъект();

	// Тогда

	Проверка = 1;
	Объект.Принять(Проверка);

	Ожидаем.Что(Проверка).Равно(2);

КонецПроцедуры

&Тест
Процедура ОбъектСКонтекстомСоздаётся() Экспорт

	// Дано

	Контекст = Новый Структура("А", 1);
	
	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х + а")
		.Интерфейс(ФункциональныеИнтерфейсы.УниФункция())
		.Контекст(Контекст);

	// Когда

	Объект = ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Объект.Применить(2)).Равно(3);

КонецПроцедуры

&Тест
Процедура ОбъектСЗахваченнымОбъектомСоздаётся() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х + ПубличноеПоле + ПриватноеПоле + Тест(4)")
		.Интерфейс(ФункциональныеИнтерфейсы.УниФункция())
		.ЗахватитьОбъект(ЗахватываемыйОбъект());

	// Когда

	Объект = ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Объект.Применить(1)).Равно(10);

КонецПроцедуры

&Тест
Процедура ОбъектСПроизвольнымИнтерфейсомСоздаётся() Экспорт

	// Дано

	Интерфейс = Новый ИнтерфейсОбъекта();
	Интерфейс.ФункцияИнтерфейса("Тест", 1);

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> х")
		.Интерфейс(Интерфейс);

	// Когда

	Объект = ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Объект.Тест(2)).Равно(2);

КонецПроцедуры

&Тест
Процедура ДействиеСоздаётся() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х")
		.Интерфейс(ФункциональныеИнтерфейсы.УниФункция());

	// Когда

	Действие = ЛямбдаВыражение.ВДействие();

	// Тогда

	Ожидаем.Что(Действие.Выполнить(1)).Равно(1);

КонецПроцедуры

&Тест
Процедура ОпределяетсяИнтерфейсДляФункцииСОднимПараметром() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> Возврат х");

	// Когда

	ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мИнтерфейс"))
		.Равно(ФункциональныеИнтерфейсы.УниФункция());

КонецПроцедуры

&Тест
Процедура ОпределяетсяИнтерфейсДляФункцииСДвумяПараметрами() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х, у -> Возврат х");

	// Когда

	ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мИнтерфейс"))
		.Равно(ФункциональныеИнтерфейсы.БиФункция());

КонецПроцедуры

&Тест
Процедура ОпределяетсяИнтерфейсДляФункцииСТремяПараметрами() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х, у, а -> Возврат х");

	// Когда

	ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мИнтерфейс"))
		.Равно(ФункциональныеИнтерфейсы.ТриФункция());

КонецПроцедуры

&Тест
Процедура ОпределяетсяИнтерфейсДляПроцедурыСОднимПараметром() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х -> х = х");

	// Когда

	ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мИнтерфейс"))
		.Равно(ФункциональныеИнтерфейсы.УниПроцедура());

КонецПроцедуры

&Тест
Процедура ОпределяетсяИнтерфейсДляПроцедурыСДвумяПараметрами() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х, у -> х = х + у");

	// Когда

	ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мИнтерфейс"))
		.Равно(ФункциональныеИнтерфейсы.БиПроцедура());

КонецПроцедуры

&Тест
Процедура ОпределяетсяИнтерфейсДляПроцедурыСТремяПараметрами() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х, у, а -> х = х + у + а");

	// Когда

	ЛямбдаВыражение.ВОбъект();

	// Тогда

	Ожидаем.Что(Рефлектор.ПолучитьСвойство(ЛямбдаВыражение, "мИнтерфейс"))
		.Равно(ФункциональныеИнтерфейсы.ТриПроцедура());

КонецПроцедуры

&Тест
Процедура ИсключениеПриНевозможностиПодобратьИнтерфейс() Экспорт

	// Дано

	ЛямбдаВыражение = Новый ЛямбдаВыражение("х, у, а, б -> х = х + у + а + б");

	// Когда

	// Тогда

	Ожидаем.Что(ЛямбдаВыражение)
		.Метод("ВОбъект")
		.ВыбрасываетИсключение("Невозможно определить функциональный интерфейс для лямбда выражения");

КонецПроцедуры

Функция ЗахватываемыйОбъект()
	
	Возврат Новый ПостроительДекоратора()
		.Метод(
			Новый Метод("Тест")
				.Публичный()
				.Параметр(Новый ПараметрМетода("Тест"))
				.ТелоМетода("Возврат Тест")
		).Поле(
			Новый Поле("ПубличноеПоле")
				.Публичное()
				.ЗначениеПоУмолчанию(2)
		).Поле(
			Новый Поле("ПриватноеПоле")
				.ЗначениеПоУмолчанию(3)
		).Построить();

КонецФункции

Рефлектор = Новый Рефлектор;
